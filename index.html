<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>HL7 v2.x Message Parser & Visualizer | Free Online HL7 Viewer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="description" content="Free online HL7 v2.x message parser and visualizer. Paste HL7, parse segments and fields, and explore field descriptions. Runs in the browser—no signup." />
  <meta name="robots" content="index, follow" />
  <link rel="canonical" href="https://chaitanyabhasme.github.io/hl7_parser/" />
  <meta name="theme-color" content="#4f46e5" />
  <meta name="author" content="Chaitanya Bhasme" />

  <!-- Open Graph -->
  <meta property="og:title" content="HL7 v2.x Message Parser & Visualizer" />
  <meta property="og:description" content="Free online HL7 message parser. Explore segments and fields with descriptions. Works entirely in your browser." />
  <meta property="og:type" content="website" />
  <meta property="og:url" content="https://chaitanyabhasme.github.io/hl7_parser/" />
  <meta property="og:site_name" content="HL7 Parser" />
  <meta property="og:locale" content="en_US" />

  <!-- Twitter Card -->
  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="HL7 v2.x Message Parser & Visualizer" />
  <meta name="twitter:description" content="Parse and visualize HL7 v2.x messages with detailed field definitions." />

  <!-- Favicon -->
  <link rel="icon" href="./favicon.svg" type="image/svg+xml" />
  <!-- Inline SVG favicon fallback (in case file not available) -->
  <link rel="icon" sizes="any" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' role='img' aria-label='HL7 Parser Icon' viewBox='0 0 64 64'%3E%3Crect width='64' height='64' rx='12' fill='%234f46e5'/%3E%3Ctext x='50%25' y='50%25' dominant-baseline='central' text-anchor='middle' font-family='Arial' font-size='26' fill='%23fff' font-weight='700'%3EHL7%3C/text%3E%3C/svg%3E" />

  <!-- Preconnects for performance -->
  <link rel="preconnect" href="https://cdn.tailwindcss.com" crossorigin />
  <link rel="preconnect" href="https://unpkg.com" crossorigin />

  <!-- Tailwind CSS CDN -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- HL7 Field/Segment Descriptions (externalized) -->
  <script src="./fields_and_descriptions.js"></script>
  <!-- Lucide Icons CDN -->
  <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.js"></script>
  <!-- React and ReactDOM CDN -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <!-- Babel Standalone CDN for JSX support -->
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <!-- Structured Data -->
  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "WebApplication",
    "name": "HL7 v2.x Message Parser & Visualizer",
    "url": "https://chaitanyabhasme.github.io/hl7_parser/",
    "description": "Free online HL7 v2.x message parser and visualizer to explore segments, fields, and definitions.",
    "applicationCategory": "UtilityApplication",
    "operatingSystem": "Web",
    "offers": {
      "@type": "Offer",
      "price": "0",
      "priceCurrency": "USD"
    },
    "softwareVersion": "1.0.0"
  }
  </script>
  <!-- FAQ Structured Data -->
  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "FAQPage",
    "mainEntity": [
      {
        "@type": "Question",
        "name": "What is HL7 v2.x?",
        "acceptedAnswer": {
          "@type": "Answer",
          "text": "HL7 v2.x is a healthcare messaging standard used to exchange clinical and administrative data between systems like EHRs, labs, and billing platforms."
        }
      },
      {
        "@type": "Question",
        "name": "Does this tool send my data to a server?",
        "acceptedAnswer": {
          "@type": "Answer",
          "text": "No. The HL7 parser runs entirely in your browser. Your message is processed locally and never leaves your device."
        }
      },
      {
        "@type": "Question",
        "name": "Which HL7 messages are supported?",
        "acceptedAnswer": {
          "@type": "Answer",
          "text": "The parser supports common HL7 v2.x messages such as ADT, ORU, ORM, and others, with human-friendly segment and field descriptions."
        }
      }
    ]
  }
  </script>
</head>
<body class="min-h-screen bg-gradient-to-br from-blue-50 to-indigo-100 p-6">
  <div id="root"></div>
  <noscript>
    <p>HL7 v2.x Message Parser & Visualizer: This tool requires JavaScript to run. Enable JavaScript to parse and visualize HL7 messages in your browser. Project: https://chaitanyabhasme.github.io/hl7_parser/</p>
  </noscript>
  <script type="text/babel">
    const { useState } = React;

    // Icon Rendering Helpers via Lucide
    function Lucide({name, className}) {
      React.useEffect(() => { lucide.createIcons(); }, []);
      return React.createElement('i', { 'data-lucide': name, className: className });
    }

    // HL7 Parser component (browser version)
    function HL7Parser() {
      const [inputText, setInputText] = useState('');
      const [parsedData, setParsedData] = useState(null);
      const [expandedSegments, setExpandedSegments] = useState(new Set());
      const [copiedSegment, setCopiedSegment] = useState(null);

      // --- segmentDescriptions and fieldDescriptions are now loaded from fields_and_descriptions.js ---

      // Parsing HL7 String Logic
      const parseHL7 = (text) => {
        if (!text.trim()) return null;
        const lines = text.split(/\r?\n/).filter(line => line.trim());
        const segments = [];
        lines.forEach(line => {
          const fieldSeparator = '|';
          const fields = line.split(fieldSeparator);
          if (fields.length > 0) {
            const segmentType = fields[0].trim();
            let segmentFields = [];
            if (segmentType === 'MSH') {
              segmentFields.push({
                position: 1,
                value: '|',
                displayValue: '|',
                description: fieldDescriptions['MSH']?.[0] || 'Field Separator',
                hasComponents: false,
                hasRepetitions: false,
                components: null,
              });
              segmentFields = segmentFields.concat(fields.slice(1).map((field, index) => {
                const hasComponents = field.includes('^');
                const hasRepetitions = field.includes('~');
                let displayValue = field;
                let components = null;
                if (hasComponents) {
                  components = field.split('^');
                  displayValue = components.map(c => c || '(empty)').join(' ^ ');
                }
                if (hasRepetitions) {
                  displayValue = field.split('~').join(' ~ ');
                }
                return {
                  position: index + 2,
                  value: field,
                  displayValue: displayValue,
                  description: fieldDescriptions['MSH']?.[index + 1] || `Field ${index + 2}`,
                  hasComponents,
                  hasRepetitions,
                  components,
                };
              }));
            } else {
              segmentFields = fields.slice(1).map((field, index) => {
                const hasComponents = field.includes('^');
                const hasRepetitions = field.includes('~');
                let displayValue = field;
                let components = null;
                if (hasComponents) {
                  components = field.split('^');
                  displayValue = components.map(c => c || '(empty)').join(' ^ ');
                }
                if (hasRepetitions) {
                  displayValue = field.split('~').join(' ~ ');
                }
                return {
                  position: index + 1,
                  value: field,
                  displayValue: displayValue,
                  description: fieldDescriptions[segmentType]?.[index] || `Field ${index + 1}`,
                  hasComponents,
                  hasRepetitions,
                  components,
                };
              });
            }
            segments.push({
              type: segmentType,
              description: segmentDescriptions[segmentType] || 'Unknown Segment',
              fields: segmentFields,
              raw: line,
            });
          }
        });
        return segments;
      };

      // UI logic and interactivity
      const handleParse = () => {
        const parsed = parseHL7(inputText);
        setParsedData(parsed);
        if (parsed) {
          setExpandedSegments(new Set(parsed.map((_, idx) => idx)));
        }
      };

      const handleClear = () => {
        setInputText('');
        setParsedData(null);
        setExpandedSegments(new Set());
      };

      const toggleSegment = (index) => {
        const newExpanded = new Set(expandedSegments);
        if (newExpanded.has(index)) newExpanded.delete(index);
        else newExpanded.add(index);
        setExpandedSegments(newExpanded);
      };

      const toggleAll = () => {
        if (expandedSegments.size === (parsedData?.length || 0)) {
          setExpandedSegments(new Set());
        } else {
          setExpandedSegments(new Set(parsedData?.map((_, idx) => idx)));
        }
      };

      const copySegment = (raw, index) => {
        navigator.clipboard.writeText(raw);
        setCopiedSegment(index);
        setTimeout(() => setCopiedSegment(null), 2000);
      };

      // Visual colors for segments
      function getSegmentColor(type) {
        const colors = {
          MSH: 'bg-blue-50 border-blue-200',
          PID: 'bg-green-50 border-green-200',
          PV1: 'bg-purple-50 border-purple-200',
          OBR: 'bg-orange-50 border-orange-200',
          OBX: 'bg-pink-50 border-pink-200',
          ORC: 'bg-yellow-50 border-yellow-200',
          NTE: 'bg-cyan-50 border-cyan-200',
        };
        return colors[type] || 'bg-gray-50 border-gray-200';
      }

      const sampleMessage = `MSH|^~\\&|SendingApp|SendingFac|ReceivingApp|ReceivingFac|20231015120000||ADT^A01|MSG001|P|2.5
PID|1||123456||Doe^John^A||19800515|M|||123 Main St^^Springfield^IL^62701|||||||
NTE|1||Patient has history of cardiac issues
NTE|2||Requires regular monitoring
PV1|1|I|ICU^101^A|||||||SUR||||||||S|||||||||||||||||||||||||20231015`;

      // Main render return
      return (
        <div>
          <div className="max-w-7xl mx-auto">
            <div className="text-center mb-8">
              <div className="flex items-center justify-center gap-3 mb-2">
                <Lucide name="file-text" className="lucide w-10 h-10 text-indigo-600" />
                <h1 className="text-4xl font-bold text-gray-800">HL7 v2.x Message Parser & Visualizer (Online)</h1>
              </div>
              <p className="text-gray-600">Free, client-side HL7 v2.x parser and viewer. Paste HL7 messages, parse segments and fields, and explore standardized field descriptions in your browser.</p>
            </div>

            <div className="bg-white rounded-lg shadow-lg p-6 mb-6">
              <h2 className="text-xl font-semibold text-gray-800 mb-4">Input HL7 Message</h2>
              <textarea
                value={inputText}
                onChange={e => setInputText(e.target.value)}
                placeholder={`Paste your HL7 message here...\n\n${sampleMessage}`}
                className="w-full h-48 p-4 border border-gray-300 rounded-lg font-mono text-sm focus:ring-2 focus:ring-indigo-500 focus:border-transparent resize-none"
              />
              <div className="flex gap-3 mt-4">
                <button
                  onClick={handleParse}
                  className="flex-1 bg-indigo-600 text-white px-6 py-3 rounded-lg font-semibold hover:bg-indigo-700 transition-colors shadow-md"
                >
                  Parse Message
                </button>
                <button
                  onClick={() => setInputText(sampleMessage)}
                  className="bg-blue-500 text-white px-6 py-3 rounded-lg font-semibold hover:bg-blue-600 transition-colors shadow-md"
                >
                  Load Sample
                </button>
                <button
                  onClick={handleClear}
                  className="flex items-center gap-2 bg-gray-500 text-white px-6 py-3 rounded-lg font-semibold hover:bg-gray-600 transition-colors shadow-md"
                >
                  <Lucide name="trash-2" className="lucide w-4 h-4" />
                  Clear
                </button>
              </div>
            </div>

            {parsedData && (
              <div className="bg-white rounded-lg shadow-lg p-6">
                <div className="flex items-center justify-between mb-6">
                  <h2 className="text-xl font-semibold text-gray-800">Parsed Message</h2>
                  <button
                    onClick={toggleAll}
                    className="text-indigo-600 hover:text-indigo-800 font-medium text-sm"
                  >
                    {expandedSegments.size === parsedData.length ? 'Collapse All' : 'Expand All'}
                  </button>
                </div>
                <div className="space-y-4">
                {parsedData.map((segment, index) => (
                  <div
                    key={index}
                    className={`border-2 rounded-lg overflow-hidden transition-all ${getSegmentColor(segment.type)}`}
                  >
                    <div className="flex items-center justify-between p-4">
                      <div
                        onClick={() => toggleSegment(index)}
                        className="flex items-center gap-3 cursor-pointer flex-1"
                      >
                        {expandedSegments.has(index) ? (
                          <Lucide name="chevron-down" className="lucide w-5 h-5 text-gray-600" />
                        ) : (
                          <Lucide name="chevron-right" className="lucide w-5 h-5 text-gray-600" />
                        )}
                        <span className="font-bold text-lg text-gray-800">{segment.type}</span>
                        <span className="text-gray-600">- {segment.description}</span>
                        <span className="text-sm text-gray-500 ml-auto mr-2">{segment.fields.length} fields</span>
                      </div>
                      <button
                        onClick={e => {
                          e.stopPropagation();
                          copySegment(segment.raw, index);
                        }}
                        className="p-2 hover:bg-gray-200 rounded transition-colors"
                        title="Copy segment"
                      >
                        {copiedSegment === index ? (
                          <Lucide name="check" className="lucide w-4 h-4 text-green-600" />
                        ) : (
                          <Lucide name="copy" className="lucide w-4 h-4 text-gray-600" />
                        )}
                      </button>
                    </div>
                    {expandedSegments.has(index) && (
                      <div className="border-t-2 border-gray-200 bg-white p-4">
                        <div className="space-y-3">
                        {segment.fields.map((field, fieldIndex) => (
                          field.value && (
                            <div key={fieldIndex} className="flex gap-4 items-start">
                              <div className="flex-shrink-0">
                                <span className="inline-block bg-indigo-100 text-indigo-700 px-3 py-1 rounded-full text-xs font-semibold">
                                  {segment.type}.{field.position}
                                </span>
                              </div>
                              <div className="flex-1">
                                <div className="text-sm font-medium text-gray-700 mb-1">
                                  {field.description}
                                </div>
                                <div className="text-sm text-gray-900 font-mono bg-gray-50 p-2 rounded border border-gray-200">
                                  {field.displayValue}
                                </div>
                                {field.hasComponents && field.components && field.components.length > 1 && (
                                  <div className="mt-2 ml-4 space-y-1">
                                    {field.components.map((comp, compIdx) => (
                                      <div key={compIdx} className="text-xs text-gray-600 flex gap-2">
                                        <span className="text-indigo-600 font-semibold">Component {compIdx + 1}:</span>
                                        <span className="font-mono">{comp || '(empty)'}</span>
                                      </div>
                                    ))}
                                  </div>
                                )}
                              </div>
                            </div>
                          )
                        ))}
                        </div>
                      </div>
                    )}
                  </div>
                ))}
                </div>
              </div>
            )}
            <section className="mt-10 bg-white rounded-lg shadow p-6">
              <h2 className="text-2xl font-semibold text-gray-800 mb-4">About this HL7 v2.x Parser</h2>
              <p className="text-gray-700 mb-4">
                This free, browser‑based HL7 viewer parses HL7 v2.x messages (ADT, ORM, ORU, and more) into readable segments and fields, complete with human‑friendly descriptions. No data leaves your device.
              </p>
              <div className="grid md:grid-cols-2 gap-6">
                <div>
                  <h3 className="font-semibold text-gray-800 mb-2">Key Features</h3>
                  <ul className="list-disc list-inside text-gray-700 space-y-1">
                    <li>Zero‑install, client‑side HL7 message parsing</li>
                    <li>Segment and field descriptions with component breakdowns</li>
                    <li>Copy segments and expand/collapse controls</li>
                    <li>Mobile‑friendly UI with keyboard support</li>
                  </ul>
                </div>
                <div>
                  <h3 className="font-semibold text-gray-800 mb-2">Use Cases</h3>
                  <ul className="list-disc list-inside text-gray-700 space-y-1">
                    <li>Debugging HL7 integrations and interfaces</li>
                    <li>Learning HL7 v2.x structure and semantics</li>
                    <li>Exploring ADT, ORU, ORM, and other message types</li>
                  </ul>
                </div>
              </div>
              <div className="mt-6">
                <h3 className="font-semibold text-gray-800 mb-2">FAQ</h3>
                <div className="space-y-2">
                  <details className="border border-gray-200 rounded">
                    <summary className="cursor-pointer px-3 py-2 font-medium">What is HL7 v2.x?</summary>
                    <div className="px-3 pb-3 text-gray-700">
                      HL7 v2.x is a widely used healthcare messaging standard for exchanging clinical and administrative data between systems such as EHRs, labs, and billing platforms.
                    </div>
                  </details>
                  <details className="border border-gray-200 rounded">
                    <summary className="cursor-pointer px-3 py-2 font-medium">Does this tool send my data to a server?</summary>
                    <div className="px-3 pb-3 text-gray-700">
                      No. Parsing happens entirely in your browser. Your HL7 message never leaves your device.
                    </div>
                  </details>
                  <details className="border border-gray-200 rounded">
                    <summary className="cursor-pointer px-3 py-2 font-medium">Which messages are supported?</summary>
                    <div className="px-3 pb-3 text-gray-700">
                      Common HL7 v2.x messages including ADT, ORU, ORM, and others. Field descriptions are included for major segments.
                    </div>
                  </details>
                </div>
              </div>
              <div className="mt-6">
                <a href="https://github.com/chaitanyabhasme/hl7_parser" className="text-indigo-600 hover:text-indigo-800 underline">View source on GitHub</a>
              </div>
            </section>
          </div>
        </div>
      );
    }

    ReactDOM.createRoot(document.getElementById('root')).render(<HL7Parser />);
    // Render Lucide icons after each render
    React.useEffect(() => { lucide.createIcons(); });
  </script>
</body>
</html>
