<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>HL7 Message Parser</title>
  <!-- Tailwind CSS CDN -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- HL7 Field/Segment Descriptions (externalized) -->
  <script src="./fields_and_descriptions.js"></script>
  <!-- Lucide Icons CDN -->
  <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.js"></script>
  <!-- React and ReactDOM CDN -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <!-- Babel Standalone CDN for JSX support -->
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body class="min-h-screen bg-gradient-to-br from-blue-50 to-indigo-100 p-6">
  <div id="root"></div>
  <script type="text/babel">
    const { useState } = React;

    // Icon Rendering Helpers via Lucide
    function Lucide({name, className}) {
      React.useEffect(() => { lucide.createIcons(); }, []);
      return React.createElement('i', { 'data-lucide': name, className: className });
    }

    // HL7 Parser component (browser version)
    function HL7Parser() {
      const [inputText, setInputText] = useState('');
      const [parsedData, setParsedData] = useState(null);
      const [expandedSegments, setExpandedSegments] = useState(new Set());
      const [copiedSegment, setCopiedSegment] = useState(null);

      // --- segmentDescriptions and fieldDescriptions are now loaded from fields_and_descriptions.js ---

      // Parsing HL7 String Logic
      const parseHL7 = (text) => {
        if (!text.trim()) return null;
        const lines = text.split(/\r?\n/).filter(line => line.trim());
        const segments = [];
        lines.forEach(line => {
          const fieldSeparator = '|';
          const fields = line.split(fieldSeparator);
          if (fields.length > 0) {
            const segmentType = fields[0].trim();
            let segmentFields = [];
            if (segmentType === 'MSH') {
              segmentFields.push({
                position: 1,
                value: '|',
                displayValue: '|',
                description: fieldDescriptions['MSH']?.[0] || 'Field Separator',
                hasComponents: false,
                hasRepetitions: false,
                components: null,
              });
              segmentFields = segmentFields.concat(fields.slice(1).map((field, index) => {
                const hasComponents = field.includes('^');
                const hasRepetitions = field.includes('~');
                let displayValue = field;
                let components = null;
                if (hasComponents) {
                  components = field.split('^');
                  displayValue = components.map(c => c || '(empty)').join(' ^ ');
                }
                if (hasRepetitions) {
                  displayValue = field.split('~').join(' ~ ');
                }
                return {
                  position: index + 2,
                  value: field,
                  displayValue: displayValue,
                  description: fieldDescriptions['MSH']?.[index + 1] || `Field ${index + 2}`,
                  hasComponents,
                  hasRepetitions,
                  components,
                };
              }));
            } else {
              segmentFields = fields.slice(1).map((field, index) => {
                const hasComponents = field.includes('^');
                const hasRepetitions = field.includes('~');
                let displayValue = field;
                let components = null;
                if (hasComponents) {
                  components = field.split('^');
                  displayValue = components.map(c => c || '(empty)').join(' ^ ');
                }
                if (hasRepetitions) {
                  displayValue = field.split('~').join(' ~ ');
                }
                return {
                  position: index + 1,
                  value: field,
                  displayValue: displayValue,
                  description: fieldDescriptions[segmentType]?.[index] || `Field ${index + 1}`,
                  hasComponents,
                  hasRepetitions,
                  components,
                };
              });
            }
            segments.push({
              type: segmentType,
              description: segmentDescriptions[segmentType] || 'Unknown Segment',
              fields: segmentFields,
              raw: line,
            });
          }
        });
        return segments;
      };

      // UI logic and interactivity
      const handleParse = () => {
        const parsed = parseHL7(inputText);
        setParsedData(parsed);
        if (parsed) {
          setExpandedSegments(new Set(parsed.map((_, idx) => idx)));
        }
      };

      const handleClear = () => {
        setInputText('');
        setParsedData(null);
        setExpandedSegments(new Set());
      };

      const toggleSegment = (index) => {
        const newExpanded = new Set(expandedSegments);
        if (newExpanded.has(index)) newExpanded.delete(index);
        else newExpanded.add(index);
        setExpandedSegments(newExpanded);
      };

      const toggleAll = () => {
        if (expandedSegments.size === (parsedData?.length || 0)) {
          setExpandedSegments(new Set());
        } else {
          setExpandedSegments(new Set(parsedData?.map((_, idx) => idx)));
        }
      };

      const copySegment = (raw, index) => {
        navigator.clipboard.writeText(raw);
        setCopiedSegment(index);
        setTimeout(() => setCopiedSegment(null), 2000);
      };

      // Visual colors for segments
      function getSegmentColor(type) {
        const colors = {
          MSH: 'bg-blue-50 border-blue-200',
          PID: 'bg-green-50 border-green-200',
          PV1: 'bg-purple-50 border-purple-200',
          OBR: 'bg-orange-50 border-orange-200',
          OBX: 'bg-pink-50 border-pink-200',
          ORC: 'bg-yellow-50 border-yellow-200',
          NTE: 'bg-cyan-50 border-cyan-200',
        };
        return colors[type] || 'bg-gray-50 border-gray-200';
      }

      const sampleMessage = `MSH|^~\\&|SendingApp|SendingFac|ReceivingApp|ReceivingFac|20231015120000||ADT^A01|MSG001|P|2.5
PID|1||123456||Doe^John^A||19800515|M|||123 Main St^^Springfield^IL^62701|||||||
NTE|1||Patient has history of cardiac issues
NTE|2||Requires regular monitoring
PV1|1|I|ICU^101^A|||||||SUR||||||||S|||||||||||||||||||||||||20231015`;

      // Main render return
      return (
        <div>
          <div className="max-w-7xl mx-auto">
            <div className="text-center mb-8">
              <div className="flex items-center justify-center gap-3 mb-2">
                <Lucide name="file-text" className="lucide w-10 h-10 text-indigo-600" />
                <h1 className="text-4xl font-bold text-gray-800">HL7 Message Parser</h1>
              </div>
              <p className="text-gray-600">Parse and visualize HL7 v2.x messages with detailed field definitions</p>
            </div>

            <div className="bg-white rounded-lg shadow-lg p-6 mb-6">
              <h2 className="text-xl font-semibold text-gray-800 mb-4">Input HL7 Message</h2>
              <textarea
                value={inputText}
                onChange={e => setInputText(e.target.value)}
                placeholder={`Paste your HL7 message here...\n\n${sampleMessage}`}
                className="w-full h-48 p-4 border border-gray-300 rounded-lg font-mono text-sm focus:ring-2 focus:ring-indigo-500 focus:border-transparent resize-none"
              />
              <div className="flex gap-3 mt-4">
                <button
                  onClick={handleParse}
                  className="flex-1 bg-indigo-600 text-white px-6 py-3 rounded-lg font-semibold hover:bg-indigo-700 transition-colors shadow-md"
                >
                  Parse Message
                </button>
                <button
                  onClick={() => setInputText(sampleMessage)}
                  className="bg-blue-500 text-white px-6 py-3 rounded-lg font-semibold hover:bg-blue-600 transition-colors shadow-md"
                >
                  Load Sample
                </button>
                <button
                  onClick={handleClear}
                  className="flex items-center gap-2 bg-gray-500 text-white px-6 py-3 rounded-lg font-semibold hover:bg-gray-600 transition-colors shadow-md"
                >
                  <Lucide name="trash-2" className="lucide w-4 h-4" />
                  Clear
                </button>
              </div>
            </div>

            {parsedData && (
              <div className="bg-white rounded-lg shadow-lg p-6">
                <div className="flex items-center justify-between mb-6">
                  <h2 className="text-xl font-semibold text-gray-800">Parsed Message</h2>
                  <button
                    onClick={toggleAll}
                    className="text-indigo-600 hover:text-indigo-800 font-medium text-sm"
                  >
                    {expandedSegments.size === parsedData.length ? 'Collapse All' : 'Expand All'}
                  </button>
                </div>
                <div className="space-y-4">
                {parsedData.map((segment, index) => (
                  <div
                    key={index}
                    className={`border-2 rounded-lg overflow-hidden transition-all ${getSegmentColor(segment.type)}`}
                  >
                    <div className="flex items-center justify-between p-4">
                      <div
                        onClick={() => toggleSegment(index)}
                        className="flex items-center gap-3 cursor-pointer flex-1"
                      >
                        {expandedSegments.has(index) ? (
                          <Lucide name="chevron-down" className="lucide w-5 h-5 text-gray-600" />
                        ) : (
                          <Lucide name="chevron-right" className="lucide w-5 h-5 text-gray-600" />
                        )}
                        <span className="font-bold text-lg text-gray-800">{segment.type}</span>
                        <span className="text-gray-600">- {segment.description}</span>
                        <span className="text-sm text-gray-500 ml-auto mr-2">{segment.fields.length} fields</span>
                      </div>
                      <button
                        onClick={e => {
                          e.stopPropagation();
                          copySegment(segment.raw, index);
                        }}
                        className="p-2 hover:bg-gray-200 rounded transition-colors"
                        title="Copy segment"
                      >
                        {copiedSegment === index ? (
                          <Lucide name="check" className="lucide w-4 h-4 text-green-600" />
                        ) : (
                          <Lucide name="copy" className="lucide w-4 h-4 text-gray-600" />
                        )}
                      </button>
                    </div>
                    {expandedSegments.has(index) && (
                      <div className="border-t-2 border-gray-200 bg-white p-4">
                        <div className="space-y-3">
                        {segment.fields.map((field, fieldIndex) => (
                          field.value && (
                            <div key={fieldIndex} className="flex gap-4 items-start">
                              <div className="flex-shrink-0">
                                <span className="inline-block bg-indigo-100 text-indigo-700 px-3 py-1 rounded-full text-xs font-semibold">
                                  {segment.type}.{field.position}
                                </span>
                              </div>
                              <div className="flex-1">
                                <div className="text-sm font-medium text-gray-700 mb-1">
                                  {field.description}
                                </div>
                                <div className="text-sm text-gray-900 font-mono bg-gray-50 p-2 rounded border border-gray-200">
                                  {field.displayValue}
                                </div>
                                {field.hasComponents && field.components && field.components.length > 1 && (
                                  <div className="mt-2 ml-4 space-y-1">
                                    {field.components.map((comp, compIdx) => (
                                      <div key={compIdx} className="text-xs text-gray-600 flex gap-2">
                                        <span className="text-indigo-600 font-semibold">Component {compIdx + 1}:</span>
                                        <span className="font-mono">{comp || '(empty)'}</span>
                                      </div>
                                    ))}
                                  </div>
                                )}
                              </div>
                            </div>
                          )
                        ))}
                        </div>
                      </div>
                    )}
                  </div>
                ))}
                </div>
              </div>
            )}
          </div>
        </div>
      );
    }

    ReactDOM.createRoot(document.getElementById('root')).render(<HL7Parser />);
    // Render Lucide icons after each render
    React.useEffect(() => { lucide.createIcons(); });
  </script>
</body>
</html>
